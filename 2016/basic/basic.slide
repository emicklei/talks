Go - Basic Training

Ernest Micklei
Software Artist, bol.com

* Who am i

- using Go since 2011
- co-organizer Golang Meetup Amsterdam
- author of *go-restful*, *hopwatch*, *forest*, *zazkia*, *assert*, *artreyu*
- bol.com: *Daxy* , *Kevlar*, *BoQs* , *Guardian*

.image img/gopher_teacher.png


* Goal

- learn using the Go language
- share experience
- have fun

* Preflight checks

- Installed Go SDK 1.7

	export GOPATH=/Users/emicklei/src
	export PATH=$GOPATH/bin:$PATH

- Finished the Tour of Go
- Configure your favorite IDE (use goimports on save)
	

* Format per Topic

- Theory
- Example
- Excercise
- Solution

* Struct

Using the struct type you can define composite types.

A struct can have zero or more fields ; each field must be typed.

A struct can embed other structs "borrowing" the state and behavior of the embedded type.

*Not* inheritance

* Example: ?

* Exercise: Graphic

Define types to model Rectangle,Circle and Point and use struct embedding.

* Solution: Graphic

.play -edit embedding.go  /START OMIT/,/END OMIT/

* Pointers

Go supports pointers, allowing you to pass references to values and records within your program.

.image /img/gopher_partyhat.webp

Variables

- & = take the address of a value

- * = dereference a pointer, an address to a value

Functions

- * = method requires pointer type

* Counter

.play pointer_receiver.go /START OMIT/,/END OMIT/


* Type Assertion

[[https://tour.golang.org/methods/15]]

A type assertion provides access to an interface value's underlying concrete value.

* Exercise:


* Solution:

* Empty Interface

	interface{}
	
Any type implements the empty interface.

	fmt.Println(1, "one", time.Time{}, []float64{3.14159} )
	
Method signature

	Println(a ...interface{}) (n int, err error)
	
If really needed then to find the actual type	

- use type assertion
- use type switch

* Exercise:  What are you?

Write functions that return the type name of two values

- "hello"
- 3.14159

The first function must use type assertion

The second function must use type switch

Extra: use fmt package

* Solution: What are you ?

.play empty_interface.go  /START OMIT/,/END OMIT/

* Interface

Interfaces are named collections of method signatures.

If a variable has an interface type, then we can call methods that are in the named interface.


* Excercise: Surface

Define the interface *Surface* with a method signature to compute the *Area* (float64) of a Graphic.

Create implementations for each graphic type (Circle, Rectangle)

Print the results.

* Solution: Surface

.code interface.go /START OMIT/,/END OMIT/

* Error is an interface

* Slice and dice

.link http://go-talks.appspot.com/github.com/emicklei/talks/2014/bolwork/case.slide#9" click me

* Synchronization

- Locking to protect against concurrent access
- "Fork & Join" pattern

.link https://golang.org/pkg/sync/
	
	Mutex
	Pool
	WaitGroup

* Example: Sequence

.play -edit sequence.go 	 /START OMIT/,/END OMIT/

* Example: Sequence (struct embedding)

.play -edit sequence2.go 	 /START OMIT/,/END OMIT/
	
* Example: WaitGroup

.play -edit waitgroup.go 	 /START OMIT/,/END OMIT/
	
* Exercise: ConcurrentHashMap

Define an interface for the operations Put and Get

- the key will be a string
- the value is a time.

Create a thread-safe implementation of a map

* Solution: ConcurrentHashMap

.code locking.go /START OMIT/,/END OMIT/

* Solution: ConcurrentHashMap (part 2)

.play -edit locking2.go /START OMIT/,/END OMIT/


* Function as value
	
toString variable has a function value	
	
	func convert(i int) string {
		return strconv.Itoa(i)
	}
	var toString = convert
	
Initialize a variable with a function	
	
	var toString = func(i int) string {
		return strconv.Itoa(i)
	}
	
Call it

	toString(42)
	
* Use function as field in struct

.play -edit func_value.go  /START OMIT/,/END OMIT/

* Function Dependency Injection

Technique to allow injection of (mock) versions of a (external) function

.code time_noinject.go   /START OMIT/,/END OMIT/

* Injectable time

.play -edit time_inject.go   /START OMIT/,/END OMIT/


* Make a Function injectable

	

* Reading and writing files

.play file_io.go  /START OMIT/,/END OMIT/


* Exercise: Backwards

Read all lines from a text file and write those lines in reverse order (first line is written last).

Extra

- reverse the runes per line too

* Solution: Backwards

.code file_io_backwards.go  /START OMIT/,/END OMIT/

* Solution: Backwards (part 2)

.code file_io_backwards2.go  /START OMIT/,/END OMIT/

* Unit testing

SDK has built-in testing framework

- files must have suffix *"_test.go"*
- function names must have prefix *"Test"*
- function argument must be pointer to a *testing.T* type

* Did i got want i want ?

	func TestComputeIt(t *testing.T) {
		amount := computeIt()
		if amount != 42 {
			t.Errorf("expected 42 but got %v",amount)
		}
	}

More compact and popular pattern

	func TestComputeIt(t *testing.T) {
		if got,want := computeIt(), 42; got != want {
			t.Errorf("got %v want %v",got,want)
		}
	}

* Table driven tests

.code table_driven.go

* Exercise: Write a test

	func concat(words ...string) string { ... }
	
* Solution: Concat
T 

* Practice Go

- learn the Go idiomatic way

- learn by reading well structured code 

- learn by doing

- Old habits...	
